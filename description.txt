### Frontend Setup
- npm install -D tailwindcss
- extension에서 Tailwind CSS IntelliSense 설치(클래스이름 자동완성 기능)
- postcss는 CSS를 post process 할수 있게 해주는 라이브러리이다.
- autoprefixer는 postcss의 또다른 plugin인데, 클래스 이름에 접두사 호환성을 추가해주는것이다. 예를들어 CSS property를 아직 firefox에 없는걸 사용한다면 호환 가능하도록 접두사를 붙여서 쓸수 있게 해주는것이다.
- npx tailwindcss init 
- Tailwind를 커스터마이즈하기 위해 tailwind config파일이 필요하고 tailwind를 일반 CSS파일로 빌드하기 위해 postcss config 파일이 필요하다.
- postcss가 tailwind.css 파일을 보고 Tailwind가 갖고 있는 모든 클래스 이름으로 바꿔준다. 또한 tailwind config 파일을 들여다보고 새 클래스 이름이 있다면 그것도 추가한다.
- package.json에 해당 스크립트 추가 "tailwind:build": "tailwind build ./src/styles/tailwind.css -o ./src/styles/styles.css" (-o은 리액트에서 import할 아웃풋이라는 의미)
- npm install @apollo/client graphql
- "--isolatedModules"에러가 나오면 재실행하기 

### Tailwind CSS 
- Tailwind CSS는 utility-first 프레임워크이다. 기본적으로 Tailwind는 엄청 긴 CSS 파일이라는 뜻이다.
- h-screen은 스크린 크기만큼 키우는 것이다.(height screen)
- bg => background color
- w : width | px : padding horizontal | py : padding vertical
- rounded : border-radius
- mt : margin top | mb : margin bottom
- tailwind의 좋은점은 일일이 css효과를 만들려면 정말 괴로운데 아름다운 class name을 통해 쉽게 할수 있도록 도와준다.
- 일일이 CSS를 모두 작성하는 대신에 tailwind.css에 input에 대한 css를 저장하고 className에 적용해준뒤 tailwind:build해주면된다.
- w-full : full witdh | max-w-screen-sm : maximum width는 작은 스크린 사이즈(640px)
- 프로젝트를 할 때 항상 모바일 먼저 생각해야한다. mt-10 같이 기본 class name은 항상 모바일로 시작해야한다.
- h-screen : 100vh의 의미이다.(viewport height 스크린의 높이)
- tailwind에서 사이즈를 정하는 방법은 %를 사용하거나 rem(사이즈 단위)을 사용한다.
- content에는 padding이 있다. 처음은 일단 padding을 봐야한다. 이렇게 하면 responsive design을 쉽게 할수 있다.
- em은 document의 font 사이즈이다. 만약 document가 16px이고 margin top을 1em으로 설정해주면 1em은 16px이라는 뜻이다.
- em은 element의 폰트 크기에 좌우된다. div가 있고 fontSize가 50px인 경우 margin Top이 1em이라고 했을때 사이즈는 50px일것이다. 
- tailwind css가 padding과 size를 이용하는 방법은 rem(root em)이다. 
- 이 뜻은 div가 있어도 margin top이 2rem일지라도 100px이 되지 않는다. rem은 body의 폰트 크기가 된다. body의 fontSize가 5px이라면 div의 margin top 2rem은 10px이 된다.   
- md: 또는 xl:이 명시되어 있지 않은 사이즈는 모바일을 우선으로 적용이 된다. tailwind는 모바일 우선 프레임워크이기 때문이다. 그 다음에 데스크탑을 설정해준다.
- w-3/12는 퍼센트를 의미한다. (부모에 대한 퍼센트)
- group-hover는 group class가 hover이면 작동한다.(group claa와 group-hover는 같이 사용해야한다.)


### Authentication 
- Local-only Fields는 GraphQL 서버의 스키마에 정의되지 않은 것을 말한다. 
- Apollo client는 GraphQL state를 다루는데 굉장히 능하다.
- local state는 server에는 없지만 application에는 있기를 바라는 state이다.
- @client를 명시해줌으로써 GraphQL이 서버한테 요구하지 않고 client cach에 요구한다.
- reactive variables는 Apollo client의 새 기능이다.
- reactive variables는 GraphQL operation을 사용할 필요없이 application의 어디에서나 읽고 수정할수 있다.
- reactive variables를 사용하면 어디서든 읽고 업데이트 할수있다. 그리고 저장은 apollo client에 한다.
- 문서에 보면 reactive variables의 값이 변경되면, 그 필드를 갖는 쿼리들이 자동으로 새로고침된다고 나와있다.
- npm install react-hook-form
- react-hook-form을 사용하는건 단 한개의 hook을 쓰는 방식과 같다.
- register은 useForm이 우리에게 제공하는 함수이다.
- register은 그냥 input의 ref안에 넣으면 된다.
- react-router-dom이 에러가 경우 1. npm install @types/react-router-dom  설치 2. react-app-env.d.ts파일에 declare module "react-router-dom" 입력하기 
- module을 선언(declare)하는 이유는 이 module은 types에 대한 폴더가 없기 때문이다.
- definitelyTyped는 typescript로 만들어지지 않은 npm packages들에 상응하는 거의 모든 typescript types를 담은 폴더이다.   
- 만약 사용하는 라이브러리에 이런 에러가 뜬다면 그 라이브러리가 typescript definition을 지원하지 않기 때문이다. 
- switch는 오직 한 route만 임포트 할수 있게 해주는 장치이다.
- 만약 input에 name이 없으면 useForm이 찾지 못한다.
- React.FC의 FC는 Functional Component의 약자이다.
- mutation PotatoMutation($email:String!, $password:String!)에서 $는 변수라는 뜻이다. 또한 이부분은 서버와 상관이 없고 오직 프런트의 Apollo를 위한것이다. Apollo는 이 변수들을 살펴볼거고 이 변수들을 가지고 mutation을 만들것이다.
- useMutation Hook의 첫번째 Argument는 mutation function이다. 이 function은 mutation의 방아쇠 역할을 한다.
- useMutation Hook의 두번째 Argument는 loading, error, data 객체이다. data는 mutation으로부터 되돌아 온다는 것이다. loading은 mutation이 실행되고 있다는 의미이고 error는 mutation이 error를 반환한다는 것이다.
- npm install -g apollo && npm install apollo 
- apollo-tooling은 백엔드에서 mutaions, query responses, input type을 전부다 typescript 정의로 자동 생성해준다. 이 말은 mutaion을 보낼때 백엔드에 데이터를 전송한다는 것을 확신할수있고 또한 response를 받으면 내가 받은 response의 type을 알수 있다. DTO가 모든것의 시작이라는 점을 기억해야한다. DTO가 schema가 되었고 schema가 프런트를 위한 typescript가 되었다.
- apollo가 하는 일은 나의 file을 보면서 gql``태그를 사용할때마다 typescript definition을 준다.
- apollo client:codegen src/__generated__ --target=typescript --outputFlat
- apollo codegen은 우선 나의 file을 살펴보고 내가 필요하다고 했던 모든 변수들의 interface를 제공해준다. 그 다음 백엔드의 실재 schema를 살펴본다.
- login component가 src폴더 밖에 까지 도달하지 못하기 때문에 codegen 생성시 src폴더에 넣어주는 것이 중요하다.
- onCompleted는 내가 다룰수있는 data를 제공해준다. 또한 loginMutation은 error, loading, called 등을 제공해준다.
- rimraf는 node.js를 위햔 rm -rf이다.
- npm i rimraf
- formState의 isValid는 onChange나 onBlur에만 일어난다.
- react-helmet은 document의 head를 변경할수 있게 해준다.
- npm i react-helmet
- npm i --save-dev @types/react-helmet
- setContext는 모든 client가 만든 request의 context를 set한다.
- isLoggedInVar, authTokenVar들을 reactive variable이라고 한다.
- link는 그냥 연결할수 있는것들이다.(http, auth, web sockets 링크 등등)
- 링크를 사용하고 싶다면 Header를 Router안에 놓아야한다. 
- React를 위한 fontawesome 설치 
- npm i --save @fortawesome/fontawesome-svg-core
- npm i --save @fortawesome/free-solid-svg-icons
- npm i --save @fortawesome/react-fontawesome
- useMe() 훅이 한번 호출되면 apollo가 자동으로 캐시에 넣어놓아서 다시 호출해도 바로 사용할수 있다.

### USER PAGES
- ClientRoutes는 Array이기 때문에 key가 필요하다.
- writeFragment에서 Fragment는 type의 일부분이다.
- Apollo가 type에 id속성이 있으면, model의 id로 사용한다.
- https://www.apollographql.com/docs/react/caching/cache-interaction/#writefragment
- useQuery는 refetch라는 흥미로운 속성이 있다. refetch는 function인데 이걸 call 하면 query를 다시 fetch해준다.
- refetch는 다시 API를 call하는것이기 때문에 fragment를 사용하는게 훨씬 빠르다.